Enunciado ExercÃ­cio:
https://app.betrybe.com/learn/course/5e938f69-6e32-43b3-9685-c936530fd326/module/290e715d-73e3-4b2d-a3c7-4fe113474070/section/7939c08a-6df3-4e20-81f3-9581c68d940b/day/60f19dc5-dea8-40c6-8784-2193b59f0975/lesson/93bdf9af-a7da-4c39-a0ea-e2838292fc07

Nos exercÃ­cios vamos utilizar diversos conceitos que aprendemos atÃ© aqui, praticando como Ã© pensar de uma maneira diferente, agora que sabemos um pouco mais sobre os computadores e como eles funcionam.
ExercÃ­cio 1: Crie um projeto que simularÃ¡ a arquitetura que vimos em aula. Ele deverÃ¡ ter um arquivo principal para a execuÃ§Ã£o do programa que representarÃ¡ nossoÂ Sistema OperacionalÂ e duas classes, que representarÃ£o aÂ MemÃ³ria PrincipalÂ e aÂ SecundÃ¡ria.
Cada tipo de memÃ³ria vai armazenar os dados na memÃ³ria que ela representa, sendo a Principal aquela que armazena tudo em memÃ³ria RAM e a secundÃ¡ria no disco. AtravÃ©s do Python estaremos fazendo chamadas ao Sistema Operacional para realizar essas tarefas para nÃ³s, pois ele melhor do que ninguÃ©m saberÃ¡ utilizar as memÃ³rias.Â O objetivo do nosso script serÃ¡ realizar a soma de uma lista de nÃºmeros aleatÃ³rios utilizando as duas implementaÃ§Ãµes de memÃ³ria. Os dados serÃ£o sempre armazenados como strings!
Vamos lÃ¡:
    1. Crie um novo diretÃ³rio na sua mÃ¡quina para os exercÃ­cios (pode chamar ele deÂ computadorÂ ouÂ pcÂ ğŸ˜).
       Os prÃ³ximos arquivos deverÃ£o ser criados dentro dele.
    2. Vamos comeÃ§ar a nossa memÃ³ria principal, ou memÃ³ria RAM: para isso crie um arquivoÂ main_memory.pyÂ e adicione o conteÃºdo abaixo nela. Implemente os mÃ©todosÂ getÂ eÂ load.
    â€¢ No load vocÃª adicionarÃ¡ (append) o elemento passado (value) Ã  listaÂ loaded_memory.
    â€¢ No get vocÃª retornarÃ¡ o valor presente na posiÃ§Ã£o dada (index) na listaÂ loaded_memory. Se o valor nÃ£o existir ou nÃ£o for numÃ©rico, retorneÂ 0.
1class MainMemory:
2def __init__(self):
3    self.clean()
4
5def load(self, value):
6    # Sua implementaÃ§Ã£o
7
8def get(self, index):
9    # Sua implementaÃ§Ã£o
10
11def clean(self):
12    self.loaded_memory = []
Perceba que estamos armazenando os valores na memÃ³ria RAM atravÃ©s das variÃ¡veis que definimos!
    3. Crie um arquivoÂ secondary_memory.pyÂ para ser a nossa memÃ³ria secundÃ¡ria e adicione o conteÃºdo abaixo. Mais uma vez, vocÃª serÃ¡ responsÃ¡vel pela implementaÃ§Ã£o dos mÃ©todosÂ getÂ eÂ loadÂ porÃ©m agora vocÃª deverÃ¡ utilizar a funÃ§Ã£oÂ open, para persistir esses dados em disco.
    â€¢ NoÂ load, utilizando o mÃ©todoÂ open, escreva um cÃ³digo que crie um novo arquivo utilizandoÂ next_file_nameÂ comoÂ pathÂ e salve oÂ valueÂ no conteÃºdo deste novo arquivo.
    â€¢ NoÂ get, tambÃ©m utilizando o mÃ©todoÂ open, retorne o conteÃºdo do arquivoÂ file_name. NÃ£o esqueÃ§a de converter o valor para numÃ©rico (floatÂ ouÂ int).
1from os import mkdir, listdir
2from os.path import join
3from shutil import rmtree
4
5DISK_PATH = "./disk"
6
7
8class SecondaryMemory:
9def __init__(self, disk_path=DISK_PATH):
10    self.disk_path = disk_path
11    try:
12        mkdir(self.disk_path)
13    except FileExistsError:
14        pass
15
16def load(self, value):
17    value = str(value)
18    next_index = str(len(listdir(self.disk_path)))
19    next_file_name = join(self.disk_path, next_index)
20    # Sua implementaÃ§Ã£o
21
22def get(self, index):
23    index = str(index)
24    file_name = join(self.disk_path, index)
25    # Sua implementaÃ§Ã£o
26
27def clean(self):
28    rmtree(self.disk_path)
29    mkdir(self.disk_path)
    4. Vamos criar nosso arquivo principal para gerenciar as â€œmemÃ³riasâ€ que criamos. Para isso, crie um novo arquivoÂ operating_system.pyÂ e coloque o seguinte conteÃºdo:
1from time import perf_counter
2
3from main_memory import MainMemory
4from secondary_memory import SecondaryMemory
5
6main = MainMemory()
7secondary = SecondaryMemory()
8
9# NÃºmeros aleatÃ³rios a serem somados
10RANDOM_NUMBERS = ["36912", "84300"] * 100
11
12def timer(string, initial_time):
13    """FunÃ§Ã£o auxiliar para print temporizado"""
14    print(string)
15    print(f"Tempo para a tarefa terminar: {perf_counter() - initial_time:6f}\n")
16
17
18# Desempenho da memÃ³ria primÃ¡ria
19main_load_init_time = perf_counter()
20for number in RANDOM_NUMBERS:
21    main.load(number)
22timer("NÃºmeros carregados na memÃ³ria principal", main_load_init_time)
23
24main_get_init_time = perf_counter()
25main_sum = sum([main.get(i) for i in range(len(RANDOM_NUMBERS))])
26timer(f"Soma na memÃ³ria principal: {main_sum}", main_get_init_time)
27
28main_clean_init_time = perf_counter()
29main.clean()
30timer("Clean na memÃ³ria principal", main_clean_init_time)
31
32
33# Desempenho da memÃ³ria secundÃ¡ria
34secondary_load_initial_time = perf_counter()
35for number in RANDOM_NUMBERS:
36    secondary.load(number)
37timer("NÃºmeros carregados na memÃ³ria secundÃ¡ria", secondary_load_initial_time)
38
39secondary_get_init_time = perf_counter()
40secondary_sum = sum([secondary.get(i) for i in range(len(RANDOM_NUMBERS))])
41timer(f"Soma na memÃ³ria secundÃ¡ria: {secondary_sum}", secondary_get_init_time)
42
43secondary_clean_init_time = perf_counter()
44secondary.clean()
45timer("Clean na memÃ³ria secundÃ¡ria", secondary_clean_init_time)
Perceba que o script do nosso Sistema Operacional faz a mediÃ§Ã£o do tempo que cada uma das trÃªs operaÃ§Ãµes (load, get e clean) leva para acontecer tanto na memÃ³ria principal quanto na secundÃ¡ria. AlÃ©m disso, as operaÃ§Ãµes sÃ£o testadas com uma lista de valores (RANDOM_NUMBERS).
    5. Vamos testar nosso script! Execute o comandoÂ python operating_system.pyÂ e veja a saÃ­da no console. Deu certo?! Como foram os tempos de saÃ­da?!
    6. Para deixar nosso script ainda mais legal, vamos aumentar a quantidade de nÃºmeros para serem somados. Adicione uma grande quantidade de nÃºmeros no array de nÃºmeros aleatÃ³rios. Para isso, basta adicionarÂ * 200Â ao final da linha que declara a listaÂ RANDOM_NUMBERS, para multiplicar a quantidade de elementos na lista. Rode o script novamente. Como foi o tempo de resposta agora? Deu diferenÃ§a, nÃ©? Qual foi mais rÃ¡pido?!
    7. Agora, vamos reforÃ§ar mais um conteÃºdo aprendido:
    8. Comente os trechos de cÃ³digo que fazem a operaÃ§Ã£o de limpeza (clean) da memÃ³ria.
    9. Execute o comando novamente
    10. Comente os trechos de cÃ³digo que fazem a operaÃ§Ã£o de carregamento (load) da memÃ³ria e execute novamente.
    11. Compare os resultados das somas. O que aconteceu?
ExercÃ­cio 2: Agora vamos explorar o sistema que estamos utilizando. Crie um script chamadoÂ my_platform.pyÂ e utilize-o para exibir no console as informaÃ§Ãµes solicitadas abaixo. Para isso, utilize o mÃ³duloÂ platformÂ do Python ğŸ˜.
    1. AÂ plataformaÂ que estÃ¡ sendo utilizada (linux,Â win32,Â darwin, etc);
    2. A versÃ£o (release);
    3. A arquitetura (x32Â ouÂ x64);
ExercÃ­cio 3: Agora vamos tanto explorar o hardware que estamos utilizando quanto aprender algo interessante: enviar programaticamente comandos para o shell. Crie um script chamadoÂ resources.pyÂ e utilize-o para exibir no console as informaÃ§Ãµes solicitadas abaixo. Para isso, utilize o mÃ©todoÂ check_outputÂ do mÃ³duloÂ subprocessÂ do Python ğŸ˜.
    1. InformaÃ§Ãµes sobre a sua CPU (no Linux vocÃª pode usar comandoÂ lscpu, e no OSX vocÃª pode usar o comandoÂ sysctl -n machdep.cpu.brand_string):
    2. O modelo;
    3. A quantidade deÂ cores;
    4. A velocidade emÂ Megahertz - MHz;
    5. A quantidade de cache (L1, L2, L3).
    6. InformaÃ§Ãµes sobre a memÃ³ria RAM (no Linux vocÃª pode usar comandoÂ free, e no OSX vocÃª pode usar o comandoÂ top -l 1 | head -n 10 | grep PhysMem):
    7. A quantidade total de memÃ³ria RAM disponÃ­vel em sua mÃ¡quinaÂ em megabytes - MBÂ (faÃ§a a conversÃ£o tambÃ©m ğŸ˜‰).
    8. A quantidade total de memÃ³ria RAM que estÃ¡ sendo utilizadaÂ em megabytes - MB.
ğŸ‘€Â De olho na dica:
    â€¢ O mÃ©todoÂ decode("UTF-8")Â vai ser Ãºtil para ler os dados oriundos daÂ check_output;
    â€¢ Os mÃ©todosÂ splitÂ eÂ stripÂ vÃ£o ser Ãºteis para limpar e separar as informaÃ§Ãµes obtidas com os comandos;
    â€¢ O mÃ©todoÂ startswithÂ vai ser Ãºtil para selecionar informaÃ§Ãµes especÃ­ficas.
    â€¢ Se estiver muito difÃ­cil fazer a filtragem e limpeza dos dados, se contente com a exibiÃ§Ã£o de informaÃ§Ãµes a mais ğŸ˜‰
ExercÃ­cio 4: FaÃ§a um script que, a cada intervalo de segundo, mostre no console a memÃ³ria utilizada do sistema operacionalÂ vsÂ a memÃ³ria total (ambos emÂ megabytes - MB). Lembre-se que vocÃª pode se basear no script do exercÃ­cio anterior.
ExercÃ­cio 5: FaÃ§a um script que exibe o seu respectivoÂ process idÂ utilizando o mÃ³duloÂ osÂ do Python e entÃ£o fique em execuÃ§Ã£o por um determinado tempo. Agora utilizando os comandos de monitoramento visto no conteÃºdo, exiba os processos em execuÃ§Ã£o e entÃ£o identifique o seu processo.
